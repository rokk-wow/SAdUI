local addonName = ...
local SAdCore = LibStub("SAdCore-1")
local addon = SAdCore:GetAddon(addonName)

addon.savedVarsGlobalName = "SAdUI_Settings_Global"
addon.savedVarsPerCharName = "SAdUI_Settings_Char"
addon.compartmentFuncName = "SAdUI_Compartment_Func"

function addon:LoadConfig()
    self.config.version = "1.0"
    self.author = "RÃ´kk-Wyrmrest Accord"

    addon:RegisterEvent("PLAYER_ENTERING_WORLD", addon.OnPlayerEnteringWorld)
    addon:RegisterEvent("PLAYER_REGEN_ENABLED", addon.OnPlayerRegenEnabled)
    addon:RegisterEvent("PLAYER_REGEN_DISABLED", addon.OnPlayerRegenDisabled)
    addon:RegisterEvent("PLAYER_FOCUS_CHANGED", addon.OnPlayerFocusChanged)
end

addon.updateUI = {}
addon.vars = {
    borderWidth = 2,
    borderColor = "000000FF",
    iconZoom = .2
}
addon.pendingUIUpdate = false
addon.focusHighlightFrame = nil
addon.kickOnCooldown = nil

-- Comprehensive list of all action bar button prefixes
addon.actionBarPrefixes = {
    "ActionButton",              -- Main action bar (1-12)
    "MultiBarBottomLeftButton",  -- Bottom left bar (1-12)
    "MultiBarBottomRightButton", -- Bottom right bar (1-12)
    "MultiBarRightButton",       -- Right bar (1-12)
    "MultiBarLeftButton",        -- Right bar 2 (1-12)
    "MultiBar5Button",           -- Additional bar 5 (1-12)
    "MultiBar6Button",           -- Additional bar 6 (1-12)
    "MultiBar7Button",           -- Additional bar 7 (1-12)
}

-- Helper function to iterate over all action buttons
function addon:IterateActionButtons(callback)
    if type(callback) ~= "function" then
        -- addon:debug("ERROR: IterateActionButtons requires a callback function")
        return
    end
    
    for _, prefix in ipairs(addon.actionBarPrefixes) do
        for i = 1, 12 do
            local buttonName = prefix .. i
            local button = _G[buttonName]
            if button then
                callback(button, buttonName)
            end
        end
    end
end

function addon.updateUI.exampleOne()
    -- addon:debug("exampleOne fired!")
end

function addon.updateUI.hideTotemFrame()
    -- addon:debug("Hiding totem frame")
    if TotemFrame then
        TotemFrame:Hide()
        TotemFrame:SetAlpha(0)
        
        -- Hook to keep it hidden
        hooksecurefunc(TotemFrame, "Show", function(self)
            self:Hide()
            self:SetAlpha(0)
        end)
    end
end

function addon.updateUI.hideQuickJoinToastButton()
    -- addon:debug("Hiding Quick Join Toast Button")
    if QuickJoinToastButton then
        QuickJoinToastButton:Hide()
        QuickJoinToastButton:SetAlpha(0)
        
        -- Hook to keep it hidden
        hooksecurefunc(QuickJoinToastButton, "Show", function(self)
            self:Hide()
            self:SetAlpha(0)
        end)
    end
end

function addon.updateUI.hideChatFrameChannelButton()
    -- addon:debug("Hiding Chat Frame Channel Button")
    if ChatFrameChannelButton then
        ChatFrameChannelButton:Hide()
        ChatFrameChannelButton:SetAlpha(0)
        
        -- Hook to keep it hidden
        hooksecurefunc(ChatFrameChannelButton, "Show", function(self)
            self:Hide()
            self:SetAlpha(0)
        end)
    end
end

function addon.updateUI.hideSpellActivationOverlay()
    -- addon:debug("Hiding Spell Activation Overlay (aura glow)")
    if SpellActivationOverlayFrame then
        SpellActivationOverlayFrame:Hide()
        SpellActivationOverlayFrame:SetAlpha(0)
        
        -- Hook to keep it hidden
        hooksecurefunc(SpellActivationOverlayFrame, "Show", function(self)
            self:Hide()
            self:SetAlpha(0)
        end)
    end
end

function addon.updateUI.hideSpellCastAnimFrame()
    -- addon:debug("Hiding spell cast animation frames on action buttons")
    
    local function hideButtonGlow(button)
        if button and button.SpellCastAnimFrame then
            -- Permanently hide the entire frame
            button.SpellCastAnimFrame:SetAlpha(0)
            button.SpellCastAnimFrame:Hide()
            
            -- Hook Show to keep it hidden without overriding the function
            hooksecurefunc(button.SpellCastAnimFrame, "Show", function(self)
                self:SetAlpha(0)
            end)
            
            -- Hide all child textures and frames
            if button.SpellCastAnimFrame.Fill then
                button.SpellCastAnimFrame.Fill:SetAlpha(0)
                button.SpellCastAnimFrame.Fill:Hide()
                hooksecurefunc(button.SpellCastAnimFrame.Fill, "Show", function(self)
                    self:SetAlpha(0)
                end)
            end
            if button.SpellCastAnimFrame.InnerGlow then
                button.SpellCastAnimFrame.InnerGlow:SetAlpha(0)
                button.SpellCastAnimFrame.InnerGlow:Hide()
                hooksecurefunc(button.SpellCastAnimFrame.InnerGlow, "Show", function(self)
                    self:SetAlpha(0)
                end)
            end
            if button.SpellCastAnimFrame.FillMask then
                button.SpellCastAnimFrame.FillMask:SetAlpha(0)
                button.SpellCastAnimFrame.FillMask:Hide()
                hooksecurefunc(button.SpellCastAnimFrame.FillMask, "Show", function(self)
                    self:SetAlpha(0)
                end)
            end
            if button.SpellCastAnimFrame.Ants then
                button.SpellCastAnimFrame.Ants:SetAlpha(0)
                button.SpellCastAnimFrame.Ants:Hide()
                hooksecurefunc(button.SpellCastAnimFrame.Ants, "Show", function(self)
                    self:SetAlpha(0)
                end)
            end
            if button.SpellCastAnimFrame.Spark then
                button.SpellCastAnimFrame.Spark:SetAlpha(0)
                button.SpellCastAnimFrame.Spark:Hide()
                hooksecurefunc(button.SpellCastAnimFrame.Spark, "Show", function(self)
                    self:SetAlpha(0)
                end)
            end
        end
        
        -- Hide interrupt display
        if button and button.InterruptDisplay then
            button.InterruptDisplay:SetAlpha(0)
            button.InterruptDisplay:Hide()
            hooksecurefunc(button.InterruptDisplay, "Show", function(self)
                self:SetAlpha(0)
            end)
            if button.InterruptDisplay.Base then
                button.InterruptDisplay.Base:SetAlpha(0)
                button.InterruptDisplay.Base:Hide()
            end
            if button.InterruptDisplay.Highlight then
                button.InterruptDisplay.Highlight:SetAlpha(0)
                button.InterruptDisplay.Highlight:Hide()
            end
        end
        
        -- Hide CheckedTexture (inner glow when casting)
        if button then
            local checkedTexture = button:GetCheckedTexture()
            if checkedTexture then
                checkedTexture:SetAlpha(0)
                checkedTexture:Hide()
            end
            -- Disable the checked state
            hooksecurefunc(button, "SetChecked", function(self)
                if self:GetChecked() then
                    local tex = self:GetCheckedTexture()
                    if tex then
                        tex:SetAlpha(0)
                        tex:Hide()
                    end
                end
            end)
        end
    end
    
    -- Iterate over all action buttons using the shared helper
    addon:IterateActionButtons(function(button, buttonName)
        hideButtonGlow(button)
    end)
    
    -- addon:debug("Finished hiding spell cast animation frames")
end

function addon.updateUI.hideMacroText()
    -- addon:debug("Hiding macro text on action buttons")
    
    local function hideButtonMacroText(button, buttonName)
        if button and button.Name then
            button.Name:SetAlpha(0)
            button.Name:Hide()
            -- Hook to keep it hidden without overriding Show()
            hooksecurefunc(button.Name, "Show", function(self)
                self:SetAlpha(0)
            end)
            -- addon:debug("Hid macro text for: " .. buttonName)
        end
    end
    
    -- Iterate over all action buttons using the shared helper
    addon:IterateActionButtons(hideButtonMacroText)
    
    -- addon:debug("Finished hiding macro text")
end

function addon.updateUI.hideKeybindText()
    -- addon:debug("Hiding keybind text on action buttons")
    
    local function hideButtonKeybind(button, buttonName)
        if button and button.HotKey then
            button.HotKey:SetAlpha(0)
            button.HotKey:Hide()
            -- Hook to keep it hidden without overriding Show()
            hooksecurefunc(button.HotKey, "Show", function(self)
                self:SetAlpha(0)
            end)
            -- addon:debug("Hid keybind text for: " .. buttonName)
        end
    end
    
    -- Iterate over all action buttons using the shared helper
    addon:IterateActionButtons(hideButtonKeybind)
    
    -- addon:debug("Finished hiding keybind text")
end

function addon.updateUI.setCVars()
    -- addon:debug("Setting CVars")
    
    SetCVar("mapFade", 0)
    -- addon:debug("Set mapFade to 0")
    
    -- addon:debug("Finished setting CVars")
end

function addon.updateUI.addActionButtonBorders()
    -- addon:debug("Adding borders to action buttons")
    
    local function addButtonBorder(button, buttonName)
        if button then
            -- Hide the default rounded border texture
            local normalTexture = button:GetNormalTexture()
            if normalTexture then
                normalTexture:SetAlpha(0)
                normalTexture:Hide()
            end
            
            -- Also hide the NormalTexture2 if it exists
            if button.NormalTexture then
                button.NormalTexture:SetAlpha(0)
                button.NormalTexture:Hide()
            end
            
            addon:addBorder(button)
            -- addon:debug("Added border to: " .. buttonName)
        end
    end
    
    -- Iterate over all action buttons using the shared helper
    addon:IterateActionButtons(addButtonBorder)
    
    -- addon:debug("Finished adding borders to action buttons")
end

function addon.updateUI.setButtonPadding()
    -- addon:debug("Setting button padding on action bars")
    
    local padding = addon.vars.buttonPadding
    
    -- Map button prefixes to their parent bar frames
    local barMap = {
        ActionButton = MainMenuBar,
        MultiBarBottomLeftButton = MultiBarBottomLeft,
        MultiBarBottomRightButton = MultiBarBottomRight,
        MultiBarRightButton = MultiBarRight,
        MultiBarLeftButton = MultiBarLeft,
        MultiBar5Button = MultiBar5,
        MultiBar6Button = MultiBar6,
        MultiBar7Button = MultiBar7,
    }
    
    -- Set spacing on each bar's layout system
    for prefix, bar in pairs(barMap) do
        if bar then
            -- Set the button spacing attribute that Blizzard's layout system uses
            if bar.SetAttribute then
                bar:SetAttribute("buttonSpacing", padding)
                -- addon:debug("Set buttonSpacing for: " .. (bar:GetName() or prefix))
            end
            
            -- Hook the bar's layout refresh to apply our spacing
            if bar.UpdateGridLayout then
                hooksecurefunc(bar, "UpdateGridLayout", function(self)
                    if self.SetAttribute then
                        self:SetAttribute("buttonSpacing", padding)
                    end
                end)
            end
            
            -- Trigger a layout update to apply changes immediately
            if bar.UpdateGridLayout then
                bar:UpdateGridLayout()
            elseif bar.Layout then
                bar:Layout()
            end
        end
    end
    
    -- addon:debug("Finished setting button padding (Blizzard layout system will handle positioning)")
end

function addon.updateUI.zoomButtonIcons()
    -- addon:debug("Zooming button icons on action bars")
    
    local zoom = addon.vars.iconZoom
    local inset = zoom / 2
    
    local function zoomButtonIcon(button, buttonName)
        if button and button.icon then
            -- Crop the texture edges to create a zoom effect
            button.icon:SetTexCoord(inset, 1 - inset, inset, 1 - inset)
            
            -- Make the cooldown frame fill the entire button (not inset like the icon)
            if button.cooldown then
                button.cooldown:ClearAllPoints()
                button.cooldown:SetAllPoints(button)
                
                -- Set cooldown swipe color to black with 50% opacity
                button.cooldown:SetSwipeColor(0, 0, 0, 0.5)
            end
            
            -- addon:debug("Zoomed icon for: " .. buttonName .. " by " .. (zoom * 100) .. "%")
        end
    end
    
    -- Iterate over all action buttons using the shared helper
    addon:IterateActionButtons(zoomButtonIcon)
    
    -- addon:debug("Finished zooming button icons")
end

function addon.updateUI.customizeAssistedHighlightGlow()
    -- addon:debug("Customizing assisted highlight glow on action buttons")
    
    -- Function to update the assisted highlight flipbook
    local function UpdateAssistedHighlight(actionButton, shown)
        local highlightFrame = actionButton.AssistedCombatHighlightFrame
        
        -- Only show the glow if in combat
        local inCombat = UnitAffectingCombat("player")
        
        if highlightFrame and highlightFrame:IsVisible() and shown and inCombat then
            local flipbook = highlightFrame.Flipbook
            if flipbook then
                -- Set to Modern Blizzard Glow style
                flipbook:SetAtlas("UI-HUD-ActionBar-Proc-Loop-Flipbook")
                
                -- Desaturate the texture first (converts to grayscale)
                flipbook:SetDesaturated(true)
                
                -- Apply magenta color (#ff00ff)
                flipbook:SetVertexColor(1.0, 0.0, 1.0, 1.0) -- RGB: 1.0, 0.0, 1.0 = #ff00ff
                
                -- Get the flipbook animation
                local anim = flipbook.Anim:GetAnimations()
                if anim then
                    -- Configure the animation for Modern Blizzard Glow
                    flipbook:ClearAllPoints()
                    flipbook:SetSize(flipbook:GetSize())
                    flipbook:SetPoint("CENTER", highlightFrame, "CENTER", -1.5, 1)
                    
                    -- Restart the animation
                    flipbook.Anim:Stop()
                    flipbook.Anim:Play()
                end
                
                -- addon:debug("Updated assisted highlight glow for button: " .. (actionButton:GetName() or "unknown"))
            end
        elseif highlightFrame and not inCombat then
            -- Hide the glow when out of combat
            highlightFrame:Hide()
        end
    end
    
    -- Hook the assisted combat manager
    if AssistedCombatManager then
        hooksecurefunc(AssistedCombatManager, "SetAssistedHighlightFrameShown", function(self, actionButton, shown)
            UpdateAssistedHighlight(actionButton, shown)
        end)
        -- addon:debug("Hooked AssistedCombatManager.SetAssistedHighlightFrameShown")
    else
        -- addon:debug("WARNING: AssistedCombatManager not found")
    end
    
    -- addon:debug("Finished customizing assisted highlight glow")
end

function addon.updateUI.customizeProcGlow()
    -- addon:debug("Hiding proc glow on action buttons")
    
    -- First, hide any proc glows that are already showing
    addon:IterateActionButtons(function(button, buttonName)
        if button and button.SpellActivationAlert then
            button.SpellActivationAlert:Hide()
            button.SpellActivationAlert:SetAlpha(0)
            
            -- Hook Show to keep it hidden
            if not button.SpellActivationAlert.__SAdUI_HideHooked then
                button.SpellActivationAlert.__SAdUI_HideHooked = true
                hooksecurefunc(button.SpellActivationAlert, "Show", function(self)
                    self:Hide()
                    self:SetAlpha(0)
                end)
            end
        end
    end)
    
    -- Also hook the ActionButtonSpellAlertManager ShowAlert function
    if ActionButtonSpellAlertManager and not ActionButtonSpellAlertManager.__SAdUI_Hooked then
        ActionButtonSpellAlertManager.__SAdUI_Hooked = true
        hooksecurefunc(ActionButtonSpellAlertManager, "ShowAlert", function(self, actionButton)
            -- Make sure we have a valid button
            if type(actionButton) ~= "table" then
                actionButton = self
            end
            
            if actionButton and actionButton.SpellActivationAlert then
                actionButton.SpellActivationAlert:Hide()
                actionButton.SpellActivationAlert:SetAlpha(0)
            end
        end)
        -- addon:debug("Hooked ActionButtonSpellAlertManager.ShowAlert to hide proc glows")
    end
    
    -- addon:debug("Finished hiding proc glow")
end

function addon.updateUI.customizeBattlefieldMap()
    -- addon:debug("Customizing battlefield map border")
    
    local mapFrame = BattlefieldMapFrame
    if mapFrame then
        -- Hook the Show function to apply our customizations when the map is displayed
        hooksecurefunc(mapFrame, "Show", function()
            -- Hide the default border
            if mapFrame.BorderFrame then
                mapFrame.BorderFrame:Hide()
                mapFrame.BorderFrame:SetAlpha(0)
            end
            
            -- Create overlay frame and add custom border
            if mapFrame.ScrollContainer then
                if not mapFrame.ScrollContainer.SAdUI_BorderFrame then
                    local borderFrame = CreateFrame("Frame", nil, mapFrame.ScrollContainer)
                    borderFrame:SetAllPoints(mapFrame.ScrollContainer)
                    mapFrame.ScrollContainer.SAdUI_BorderFrame = borderFrame
                end
                addon:addBorder(mapFrame.ScrollContainer.SAdUI_BorderFrame)
            end
        end)
        
        -- Apply immediately if the map is already showing
        if mapFrame:IsShown() and mapFrame.ScrollContainer then
            if mapFrame.BorderFrame then
                mapFrame.BorderFrame:Hide()
                mapFrame.BorderFrame:SetAlpha(0)
            end
            
            if not mapFrame.ScrollContainer.SAdUI_BorderFrame then
                local borderFrame = CreateFrame("Frame", nil, mapFrame.ScrollContainer)
                borderFrame:SetAllPoints(mapFrame.ScrollContainer)
                mapFrame.ScrollContainer.SAdUI_BorderFrame = borderFrame
            end
            addon:addBorder(mapFrame.ScrollContainer.SAdUI_BorderFrame)
        end
    end
    
    -- addon:debug("Finished customizing battlefield map")
end

function addon.updateUI.scaleZoneMap()
    -- addon:debug("Scaling zone map")
    
    local scale = 1.25
    
    local mapFrame = BattlefieldMapFrame
    if mapFrame then
        mapFrame:SetScale(scale)
        -- addon:debug("Set zone map scale to: " .. tostring(scale))
    end
    
    -- addon:debug("Finished scaling zone map")
end

function addon.updateUI.unclampChatFrames()
    -- addon:debug("Unclamping chat frames from screen")
    
    for i = 1, NUM_CHAT_WINDOWS do
        local chatFrame = _G["ChatFrame" .. i]
        if chatFrame then
            chatFrame:SetClampedToScreen(false)
            -- addon:debug("Unclamped ChatFrame" .. i)
        end
    end
    
    -- addon:debug("Finished unclamping chat frames")
end

function addon.updateUI.repositionChatEditBox()
    -- addon:debug("Repositioning chat edit boxes")
    
    for i = 1, NUM_CHAT_WINDOWS do
        local editBox = _G["ChatFrame" .. i .. "EditBox"]
        if editBox then
            editBox:ClearAllPoints()
            editBox:SetPoint("TOPLEFT", _G["ChatFrame" .. i], "BOTTOMLEFT", 0, 25)
            editBox:SetPoint("TOPRIGHT", _G["ChatFrame" .. i], "BOTTOMRIGHT", 0, 0)
            
            -- Hide all border textures
            for j = 1, editBox:GetNumRegions() do
                local region = select(j, editBox:GetRegions())
                if region and region:GetObjectType() == "Texture" then
                    region:SetAlpha(0)
                    region:Hide()
                end
            end
            
            -- Add black background texture
            if not editBox.SAdUI_Background then
                editBox.SAdUI_Background = editBox:CreateTexture(nil, "BACKGROUND")
                editBox.SAdUI_Background:SetAllPoints(editBox)
                editBox.SAdUI_Background:SetColorTexture(0, 0, 0, 1)
                
                -- Hook SetShown to sync background visibility
                hooksecurefunc(editBox, "SetShown", function(self, shown)
                    if self.SAdUI_Background then
                        self.SAdUI_Background:SetShown(shown)
                    end
                end)
                
                hooksecurefunc(editBox, "SetAlpha", function(self, alpha)
                    if self.SAdUI_Background then
                        self.SAdUI_Background:SetAlpha(alpha)
                    end
                end)
            end
            
            -- Sync initial visibility and alpha
            if editBox.SAdUI_Background then
                editBox.SAdUI_Background:SetShown(editBox:IsShown())
                editBox.SAdUI_Background:SetAlpha(editBox:GetAlpha())
            end
            
            -- addon:debug("Repositioned ChatFrame" .. i .. "EditBox")
        end
    end
    
    -- addon:debug("Finished repositioning chat edit boxes")
end

function addon.updateUI.customizeMinimap()
    -- addon:debug("Customizing minimap")
    
    -- Minimap dimensions (adjustable)
    local minimapWidth = 373
    local minimapHeight = 248
    
    -- Make minimap rectangular and set size
    if Minimap then
        -- Remove the circular mask to make it rectangular
        Minimap:SetMaskTexture("Interface\\Buttons\\WHITE8X8")
        
        -- Set custom size
        Minimap:SetSize(minimapWidth, minimapHeight)
        
        -- Add border
        addon:addBorder(Minimap)
    end
    
    -- Hide MinimapBackdrop
    if MinimapBackdrop then
        MinimapBackdrop:Hide()
        MinimapBackdrop:SetAlpha(0)
    end
    
    -- Hide BorderTop
    if MinimapCluster and MinimapCluster.BorderTop then
        MinimapCluster.BorderTop:Hide()
        MinimapCluster.BorderTop:SetAlpha(0)
    end
    
    -- Hide Tracking button and background
    if MinimapCluster and MinimapCluster.Tracking then
        if MinimapCluster.Tracking.Button then
            MinimapCluster.Tracking.Button:Hide()
            MinimapCluster.Tracking.Button:SetAlpha(0)
        end
        if MinimapCluster.Tracking.Background then
            MinimapCluster.Tracking.Background:Hide()
            MinimapCluster.Tracking.Background:SetAlpha(0)
        end
    end
    
    -- Hide Zone text and background
    if MinimapCluster and MinimapCluster.ZoneTextButton then
        MinimapCluster.ZoneTextButton:Hide()
        MinimapCluster.ZoneTextButton:SetAlpha(0)
        
        -- Hide all regions (backgrounds) of ZoneTextButton
        for i = 1, MinimapCluster.ZoneTextButton:GetNumRegions() do
            local region = select(i, MinimapCluster.ZoneTextButton:GetRegions())
            if region then
                region:Hide()
                region:SetAlpha(0)
            end
        end
    end
    
    -- Hide Calendar button
    if GameTimeFrame then
        GameTimeFrame:Hide()
        GameTimeFrame:SetAlpha(0)
    end
    
    -- Hide Zoom In/Out buttons
    if Minimap then
        if Minimap.ZoomIn then
            Minimap.ZoomIn:Hide()
            Minimap.ZoomIn:SetAlpha(0)
        end
        if Minimap.ZoomOut then
            Minimap.ZoomOut:Hide()
            Minimap.ZoomOut:SetAlpha(0)
        end
    end
    
    -- Also hide global zoom buttons if they exist
    if MinimapZoomIn then
        MinimapZoomIn:Hide()
        MinimapZoomIn:SetAlpha(0)
    end
    if MinimapZoomOut then
        MinimapZoomOut:Hide()
        MinimapZoomOut:SetAlpha(0)
    end
    
    -- Force minimap to recenter by triggering a zoom operation
    if Minimap then
        C_Timer.After(0.1, function()
            local currentZoom = Minimap:GetZoom()
            -- Zoom out then back in to force recenter
            if currentZoom < Minimap:GetZoomLevels() then
                Minimap:SetZoom(currentZoom + 1)
            else
                Minimap:SetZoom(currentZoom - 1)
            end
            -- Restore original zoom level
            C_Timer.After(0.05, function()
                Minimap:SetZoom(currentZoom)
            end)
        end)
    end
    
    -- addon:debug("Finished customizing minimap")
end

function addon.updateUI.customizeClock()
    -- addon:debug("Customizing clock")
    
    local clockButton = TimeManagerClockButton
    if clockButton then
        -- Reposition to center top of screen
        clockButton:ClearAllPoints()
        clockButton:SetPoint("TOP", UIParent, "TOP", 0, -10)
        
        -- Make the text bigger and center aligned
        local ticker = TimeManagerClockTicker
        if ticker then
            ticker:SetFont(ticker:GetFont(), 18, "OUTLINE")
            ticker:SetJustifyH("CENTER")
        end
    end
    
    -- Position addon compartment to the right of clock
    if AddonCompartmentFrame and clockButton then
        AddonCompartmentFrame:ClearAllPoints()
        AddonCompartmentFrame:SetPoint("LEFT", clockButton, "RIGHT", 15, 0)
    end
    
    -- addon:debug("Finished customizing clock")
end

function addon:addBorder(bar, borderWidth, borderColor)
    if not bar then return end
    
    local size = borderWidth or self.vars.borderWidth
    local colorHex = borderColor or self.vars.borderColor
    local r, g, b, a = self:hexToRGB(colorHex)
    
    local borders = bar.SAdUnitFrames_Borders
    
    if borders then
        borders.top:SetColorTexture(r, g, b, a)
        borders.top:SetHeight(size)
        
        borders.bottom:SetColorTexture(r, g, b, a)
        borders.bottom:SetHeight(size)
        
        borders.left:SetColorTexture(r, g, b, a)
        borders.left:SetWidth(size)
        
        borders.right:SetColorTexture(r, g, b, a)
        borders.right:SetWidth(size)
    else
        borders = {}
        
        borders.top = bar:CreateTexture(nil, "OVERLAY")
        borders.top:SetColorTexture(r, g, b, a)
        borders.top:SetHeight(size)
        borders.top:ClearAllPoints()
        borders.top:SetPoint("TOPLEFT", bar, "TOPLEFT", 0, 0)
        borders.top:SetPoint("TOPRIGHT", bar, "TOPRIGHT", 0, 0)
        
        borders.bottom = bar:CreateTexture(nil, "OVERLAY")
        borders.bottom:SetColorTexture(r, g, b, a)
        borders.bottom:SetHeight(size)
        borders.bottom:ClearAllPoints()
        borders.bottom:SetPoint("BOTTOMLEFT", bar, "BOTTOMLEFT", 0, 0)
        borders.bottom:SetPoint("BOTTOMRIGHT", bar, "BOTTOMRIGHT", 0, 0)
        
        borders.left = bar:CreateTexture(nil, "OVERLAY")
        borders.left:SetColorTexture(r, g, b, a)
        borders.left:SetWidth(size)
        borders.left:ClearAllPoints()
        borders.left:SetPoint("TOPLEFT", bar, "TOPLEFT", 0, 0)
        borders.left:SetPoint("BOTTOMLEFT", bar, "BOTTOMLEFT", 0, 0)
        
        borders.right = bar:CreateTexture(nil, "OVERLAY")
        borders.right:SetColorTexture(r, g, b, a)
        borders.right:SetWidth(size)
        borders.right:ClearAllPoints()
        borders.right:SetPoint("TOPRIGHT", bar, "TOPRIGHT", 0, 0)
        borders.right:SetPoint("BOTTOMRIGHT", bar, "BOTTOMRIGHT", 0, 0)
        
        bar.SAdUnitFrames_Borders = borders
    end
end

function addon.updateUI.addActionBarBackgrounds()
    local bars = {
        { name = "MainMenuBar", frame = MainMenuBar },
        { name = "MultiBarBottomLeft", frame = MultiBarBottomLeft },
        { name = "MultiBarBottomRight", frame = MultiBarBottomRight },
        { name = "MultiBarRight", frame = MultiBarRight },
        { name = "MultiBarLeft", frame = MultiBarLeft },
        { name = "MultiBar5", frame = MultiBar5 },
        { name = "MultiBar6", frame = MultiBar6 },
        { name = "MultiBar7", frame = MultiBar7 },
    }
    
    for _, barInfo in ipairs(bars) do
        local bar = barInfo.frame
        
        if bar and bar.GetSettingValueBool then
            -- Check if "Always Show Buttons" is enabled (setting 9)
            local alwaysShowButtons = bar:GetSettingValueBool(9)
            
            if alwaysShowButtons and not bar.SAdUI_Background then
                local bg = bar:CreateTexture(nil, "BACKGROUND")
                bg:SetAllPoints(bar)
                bg:SetColorTexture(0, 0, 0, 0.5)
                bar.SAdUI_Background = bg
            end
        end
    end
end

function addon:CreateProcGlow(parent, r, g, b)
    -- Create proc glow frame manually
    local procGlow = CreateFrame("Frame", nil, parent)
    procGlow:SetSize(parent:GetWidth() * 1.4, parent:GetHeight() * 1.4)
    procGlow:SetPoint("CENTER")
    
    -- Create proc loop flipbook texture (the continuous glow)
    local procLoop = procGlow:CreateTexture(nil, "ARTWORK")
    procLoop:SetAtlas("UI-HUD-ActionBar-Proc-Loop-Flipbook")
    procLoop:SetAllPoints(procGlow)
    procLoop:SetAlpha(0)
    
    -- Only apply color/desaturation if color parameters are provided
    if r ~= nil and g ~= nil and b ~= nil then
        procLoop:SetDesaturated(true)
        procLoop:SetVertexColor(r, g, b)
    end
    
    procGlow.ProcLoopFlipbook = procLoop
    
    -- Create animation group for proc loop
    local procLoopAnim = procGlow:CreateAnimationGroup()
    procLoopAnim:SetLooping("REPEAT")
    
    local alpha = procLoopAnim:CreateAnimation("Alpha")
    alpha:SetChildKey("ProcLoopFlipbook")
    alpha:SetDuration(0.001)
    alpha:SetOrder(0)
    alpha:SetFromAlpha(1)
    alpha:SetToAlpha(1)
    
    local flip = procLoopAnim:CreateAnimation("FlipBook")
    flip:SetChildKey("ProcLoopFlipbook")
    flip:SetDuration(1)
    flip:SetOrder(0)
    flip:SetFlipBookRows(6)
    flip:SetFlipBookColumns(5)
    flip:SetFlipBookFrames(30)
    
    procGlow.ProcLoop = procLoopAnim
    
    return procGlow
end

function addon.updateUI.customizeEssentialCooldowns()
    local function ApplyCooldownColor(cooldownFrame)
        if cooldownFrame and cooldownFrame.SetSwipeColor then
            cooldownFrame:SetSwipeColor(0, 0, 0, 0.9)
        end
    end
    
    local function SetupCooldownHooks()
        if not EssentialCooldownViewer then
            return
        end
        
        -- Hook each child's Cooldown frame
        for _, child in pairs({EssentialCooldownViewer:GetChildren()}) do
            if child.Cooldown and not child.cooldownHooked then
                -- Hook SetCooldown to apply color whenever cooldown is set
                hooksecurefunc(child.Cooldown, "SetCooldown", function(self)
                    ApplyCooldownColor(self)
                end)
                
                -- Also apply immediately
                ApplyCooldownColor(child.Cooldown)
                
                child.cooldownHooked = true
            end
        end
    end
    
    -- Run setup after a delay
    C_Timer.After(1, SetupCooldownHooks)
    
    -- Rerun periodically to catch newly created frames
    C_Timer.NewTicker(5, SetupCooldownHooks)
end

function addon.updateUI.addBuffIconGlow()
    local function OnUnitAura(event, unit)
        if unit ~= "player" then return end
        
        if BuffIconCooldownViewer then
            for _, child in pairs({BuffIconCooldownViewer:GetChildren()}) do
                if child.Icon and not child.SAdUI_ProcGlow then
                    local procGlow = addon:CreateProcGlow(child, 0, 1.0, 0.596)
                    procGlow.ProcLoop:Play()
                    child.SAdUI_ProcGlow = procGlow
                end
            end
        end
    end
    
    addon:RegisterEvent("UNIT_AURA", OnUnitAura)
end

function addon:OnPlayerEnteringWorld()
    -- addon:debug("PLAYER_ENTERING_WORLD event fired")
    addon:RunUIUpdates()
end

function addon:OnPlayerRegenEnabled()
    -- addon:debug("Leaving combat")
    
    -- Hide all assisted highlight glows when leaving combat
    addon:UpdateAssistedHighlightVisibility()
    
    if addon.pendingUIUpdate then
        -- addon:debug("Running pending UI updates after combat")
        addon.pendingUIUpdate = false
        addon:RunUIUpdates()
    end
end

function addon:OnPlayerRegenDisabled()
    -- addon:debug("Entering combat")
    
    -- Show assisted highlight glows when entering combat (if they should be visible)
    addon:UpdateAssistedHighlightVisibility()
end



function addon:UpdateAssistedHighlightVisibility()
    local inCombat = UnitAffectingCombat("player")
    
    addon:IterateActionButtons(function(button, buttonName)
        if button and button.AssistedCombatHighlightFrame then
            local highlightFrame = button.AssistedCombatHighlightFrame
            if not inCombat then
                -- Force hide when out of combat
                highlightFrame:Hide()
            end
            -- When in combat, let the normal assisted combat system handle visibility
        end
    end)
end

function addon:RunUIUpdates()
    if InCombatLockdown() then
        -- addon:debug("In combat lockdown - deferring UI updates")
        addon.pendingUIUpdate = true
        return
    end
    
    -- Delay UI updates to ensure Blizzard UI is fully loaded and to avoid tainting during initialization
    C_Timer.After(0.5, function()
        if InCombatLockdown() then
            -- addon:debug("In combat after delay - deferring UI updates")
            addon.pendingUIUpdate = true
            return
        end
        
        -- addon:debug("Running all updateUI functions")
        for funcName, func in pairs(addon.updateUI) do
            -- addon:debug("Found updateUI entry: " .. funcName .. " (type: " .. type(func) .. ")")
            if type(func) == "function" then
                -- addon:debug("Running updateUI." .. funcName)
                func()
                -- addon:debug("Completed updateUI." .. funcName)
            end
        end
        -- addon:debug("Finished running all updateUI functions")
    end)
end

function addon.updateUI.customizeEssentialCooldownFlash()
    local function CustomizeCooldownFlash()
        if not EssentialCooldownViewer then
            return
        end
        
        for _, child in pairs({EssentialCooldownViewer:GetChildren()}) do
            if child.CooldownFlash and child.CooldownFlash.Flipbook then
                local flipbook = child.CooldownFlash.Flipbook
                
                -- Make it magenta/pink so we can easily see the change
                flipbook:SetDesaturated(true)
                flipbook:SetVertexColor(1.0, 0.0, 1.0, 1.0) -- Magenta
            end
        end
    end
    
    -- Run setup after a delay
    C_Timer.After(1, CustomizeCooldownFlash)
    
    -- Rerun periodically to catch newly created frames
    C_Timer.NewTicker(5, CustomizeCooldownFlash)
end
